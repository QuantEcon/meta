name: 'Check for Python Warnings'
description: 'Scan HTML files for Python warnings within code cell outputs (avoiding false positives from text content)'
author: 'QuantEcon'

inputs:
  html-path:
    description: 'Path to directory containing HTML files to scan'
    required: false
    default: '.'
  warnings:
    description: 'Comma-separated list of warnings to check for'
    required: false
    default: 'UserWarning,DeprecationWarning,PendingDeprecationWarning,SyntaxWarning,RuntimeWarning,FutureWarning,ImportWarning,UnicodeWarning,BytesWarning,ResourceWarning,EncodingWarning'
  exclude-warning:
    description: 'Comma-separated list of warnings to exclude from checking (can be a single warning or multiple warnings)'
    required: false
    default: ''
  fail-on-warning:
    description: 'Whether to fail the workflow if warnings are found'
    required: false
    default: 'true'
  create-issue:
    description: 'Whether to create a GitHub issue when warnings are found'
    required: false
    default: 'false'
  issue-title:
    description: 'Title for the GitHub issue when warnings are found'
    required: false
    default: 'Python Warnings Found in Documentation Build'
  create-artifact:
    description: 'Whether to create a workflow artifact with the warning report'
    required: false
    default: 'false'
  artifact-name:
    description: 'Name for the workflow artifact containing the warning report'
    required: false
    default: 'warning-report'
  notify:
    description: 'GitHub username(s) to assign to the created issue (comma-separated for multiple users)'
    required: false
    default: ''
  pr-mode:
    description: 'When enabled, only check HTML files corresponding to changed .md files in the PR (requires git repository context)'
    required: false
    default: 'false'

outputs:
  warnings-found:
    description: 'Whether warnings were found (true/false)'
    value: ${{ steps.check.outputs.warnings-found }}
  warning-count:
    description: 'Number of warnings found'
    value: ${{ steps.check.outputs.warning-count }}
  warning-details:
    description: 'Details of warnings found'
    value: ${{ steps.check.outputs.warning-details }}
  issue-url:
    description: 'URL of the created GitHub issue (if create-issue is enabled)'
    value: ${{ steps.create-issue.outputs.issue-url }}
  artifact-path:
    description: 'Path to the created artifact file (if create-artifact is enabled)'
    value: ${{ steps.create-artifact.outputs.artifact-path }}

runs:
  using: 'composite'
  steps:
    - name: Check for warnings
      id: check
      shell: bash
      run: |
        # Parse inputs
        HTML_PATH="${{ inputs.html-path }}"
        WARNINGS="${{ inputs.warnings }}"
        EXCLUDE_WARNINGS="${{ inputs.exclude-warning }}"
        FAIL_ON_WARNING="${{ inputs.fail-on-warning }}"
        PR_MODE="${{ inputs.pr-mode }}"
        
        echo "Scanning HTML files in: $HTML_PATH"
        echo "Looking for warnings: $WARNINGS"
        echo "PR mode: $PR_MODE"
        
        # Convert comma-separated warnings to array
        IFS=',' read -ra WARNING_ARRAY <<< "$WARNINGS"
        
        # Handle exclude-warning parameter
        if [ -n "$EXCLUDE_WARNINGS" ]; then
          echo "Excluding warnings: $EXCLUDE_WARNINGS"
          # Convert comma-separated exclude warnings to array
          IFS=',' read -ra EXCLUDE_ARRAY <<< "$EXCLUDE_WARNINGS"
          
          # Create a new array with warnings not in exclude list
          FILTERED_WARNING_ARRAY=()
          for warning in "${WARNING_ARRAY[@]}"; do
            # Remove leading/trailing whitespace from warning
            warning=$(echo "$warning" | xargs)
            exclude_warning=false
            
            # Check if this warning should be excluded
            for exclude in "${EXCLUDE_ARRAY[@]}"; do
              # Remove leading/trailing whitespace from exclude warning
              exclude=$(echo "$exclude" | xargs)
              if [ "$warning" = "$exclude" ]; then
                exclude_warning=true
                break
              fi
            done
            
            # Add to filtered array if not excluded
            if [ "$exclude_warning" = false ]; then
              FILTERED_WARNING_ARRAY+=("$warning")
            fi
          done
          
          # Replace WARNING_ARRAY with filtered array
          WARNING_ARRAY=("${FILTERED_WARNING_ARRAY[@]}")
          
          # Show final warning list
          if [ ${#WARNING_ARRAY[@]} -eq 0 ]; then
            echo "âš ï¸  All warnings have been excluded. No warnings will be checked."
          else
            echo "Final warning list after exclusions: ${WARNING_ARRAY[*]}"
          fi
        fi
        
        # Initialize counters
        TOTAL_WARNINGS=0
        WARNING_DETAILS=""
        WARNINGS_FOUND="false"
        DETAILED_REPORT=""
        
        # Find HTML files to check
        if [ ! -e "$HTML_PATH" ]; then
          echo "Error: HTML path '$HTML_PATH' does not exist"
          exit 1
        fi
        
        # Handle PR mode - only check HTML files corresponding to changed .md files
        if [ "$PR_MODE" = "true" ]; then
          echo "Running in PR mode - detecting changed .md files..."
          
          # Get the list of changed .md files in this PR/push
          CHANGED_MD_FILES=()
          
          # Try to get changed files from git
          if command -v git >/dev/null 2>&1; then
            # For pull requests, compare against the base branch
            if [ -n "${GITHUB_BASE_REF:-}" ]; then
              # This is a pull request
              BASE_REF="${GITHUB_BASE_REF}"
              echo "Comparing against base branch: $BASE_REF"
              
              # Try different comparison strategies
              if git rev-parse --verify "$BASE_REF" >/dev/null 2>&1; then
                # Base branch exists locally
                mapfile -t CHANGED_MD_FILES < <(git diff --name-only --diff-filter=AM "$BASE_REF"...HEAD | grep '\.md$' || true)
              elif git rev-parse --verify "origin/$BASE_REF" >/dev/null 2>&1; then
                # Try origin/base_ref
                mapfile -t CHANGED_MD_FILES < <(git diff --name-only --diff-filter=AM "origin/$BASE_REF"...HEAD | grep '\.md$' || true)
              else
                # Fetch the base branch and try again
                if git fetch origin "$BASE_REF:$BASE_REF" 2>/dev/null; then
                  mapfile -t CHANGED_MD_FILES < <(git diff --name-only --diff-filter=AM "$BASE_REF"...HEAD | grep '\.md$' || true)
                else
                  echo "Warning: Could not compare with base branch $BASE_REF, falling back to HEAD~1"
                  mapfile -t CHANGED_MD_FILES < <(git diff --name-only --diff-filter=AM HEAD~1...HEAD | grep '\.md$' || true)
                fi
              fi
            else
              # This is a push event, compare with previous commit
              if [ "${GITHUB_EVENT_NAME:-}" = "push" ] && [ -n "${GITHUB_EVENT_BEFORE:-}" ] && [ "${GITHUB_EVENT_BEFORE}" != "0000000000000000000000000000000000000000" ]; then
                echo "Comparing against previous commit: ${GITHUB_EVENT_BEFORE}"
                mapfile -t CHANGED_MD_FILES < <(git diff --name-only --diff-filter=AM "${GITHUB_EVENT_BEFORE}"...HEAD | grep '\.md$' || true)
              else
                # Fallback to comparing with HEAD~1
                echo "Comparing against HEAD~1"
                mapfile -t CHANGED_MD_FILES < <(git diff --name-only --diff-filter=AM HEAD~1...HEAD | grep '\.md$' || true)
              fi
            fi
          else
            echo "Warning: git command not available, falling back to scanning all files"
            PR_MODE="false"
          fi
          
          if [ ${#CHANGED_MD_FILES[@]} -eq 0 ]; then
            echo "No .md files changed in this PR - no HTML files to check"
            FILES=()
          else
            echo "Found ${#CHANGED_MD_FILES[@]} changed .md file(s):"
            printf '%s\n' "${CHANGED_MD_FILES[@]}"
            
            # Map changed .md files to corresponding .html files
            FILES=()
            for md_file in "${CHANGED_MD_FILES[@]}"; do
              # Convert .md file path to corresponding .html file in the build directory
              # Remove .md extension and add .html
              base_name=$(basename "$md_file" .md)
              
              # Look for the corresponding HTML file in the HTML_PATH
              if [ -f "$HTML_PATH" ]; then
                # HTML_PATH is a single file, only check if it matches
                html_file_name=$(basename "$HTML_PATH" .html)
                if [ "$base_name" = "$html_file_name" ]; then
                  FILES+=("$HTML_PATH")
                  echo "Mapped $md_file -> $HTML_PATH"
                fi
              else
                # HTML_PATH is a directory, search for corresponding HTML file
                # Try different possible mappings
                possible_paths=(
                  "$HTML_PATH/$base_name.html"
                  "$HTML_PATH/$(dirname "$md_file")/$base_name.html"
                )
                
                for html_path in "${possible_paths[@]}"; do
                  if [ -f "$html_path" ]; then
                    FILES+=("$html_path")
                    echo "Mapped $md_file -> $html_path"
                    break
                  fi
                done
                
                # If no exact match found, search recursively
                if ! printf '%s\n' "${FILES[@]}" | grep -q "/$base_name.html"; then
                  found_file=$(find "$HTML_PATH" -name "$base_name.html" -type f | head -1)
                  if [ -n "$found_file" ]; then
                    FILES+=("$found_file")
                    echo "Mapped $md_file -> $found_file (found recursively)"
                  else
                    echo "Warning: No corresponding HTML file found for $md_file"
                  fi
                fi
              fi
            done
            
            if [ ${#FILES[@]} -eq 0 ]; then
              echo "No HTML files found corresponding to changed .md files"
            else
              echo "Will check ${#FILES[@]} HTML file(s) in PR mode"
            fi
          fi
        else
          # Normal mode - find all HTML files or use specified file
          if [ -f "$HTML_PATH" ]; then
            # Single file
            if [[ "$HTML_PATH" == *.html ]]; then
              echo "Checking single HTML file: $HTML_PATH"
              FILES=("$HTML_PATH")
            else
              echo "Error: '$HTML_PATH' is not an HTML file"
              exit 1
            fi
          else
            # Directory - find all HTML files
            echo "Scanning all HTML files in directory: $HTML_PATH"
            mapfile -d '' FILES < <(find "$HTML_PATH" -name "*.html" -type f -print0)
          fi
        fi
        
        # Create temporary Python script for parsing HTML
        echo 'import re' > /tmp/check_warnings.py
        echo 'import sys' >> /tmp/check_warnings.py
        echo 'import os' >> /tmp/check_warnings.py
        echo '' >> /tmp/check_warnings.py
        echo 'def find_warnings_in_cell_outputs(file_path, warning_text):' >> /tmp/check_warnings.py
        echo '    try:' >> /tmp/check_warnings.py
        echo '        with open(file_path, "r", encoding="utf-8") as f:' >> /tmp/check_warnings.py
        echo '            content = f.read()' >> /tmp/check_warnings.py
        echo '        ' >> /tmp/check_warnings.py
        echo '        # Find all HTML elements with cell_output in the class attribute' >> /tmp/check_warnings.py
        echo '        pattern = r"<([^>]+)\s+class=\"[^\"]*cell_output[^\"]*\"[^>]*>(.*?)</\1>"' >> /tmp/check_warnings.py
        echo '        ' >> /tmp/check_warnings.py
        echo '        matches = []' >> /tmp/check_warnings.py
        echo '        ' >> /tmp/check_warnings.py
        echo '        # Search for cell_output blocks' >> /tmp/check_warnings.py
        echo '        for match in re.finditer(pattern, content, re.DOTALL | re.IGNORECASE):' >> /tmp/check_warnings.py
        echo '            block_content = match.group(2)' >> /tmp/check_warnings.py
        echo '            block_start = match.start()' >> /tmp/check_warnings.py
        echo '            ' >> /tmp/check_warnings.py
        echo '            # Count line number where this block starts' >> /tmp/check_warnings.py
        echo '            block_line = content[:block_start].count("\\n") + 1' >> /tmp/check_warnings.py
        echo '            ' >> /tmp/check_warnings.py
        echo '            # Search for warning within this block' >> /tmp/check_warnings.py
        echo '            if warning_text in block_content:' >> /tmp/check_warnings.py
        echo '                # Find specific lines within the block that contain the warning' >> /tmp/check_warnings.py
        echo '                block_lines = block_content.split("\\n")' >> /tmp/check_warnings.py
        echo '                for i, line in enumerate(block_lines):' >> /tmp/check_warnings.py
        echo '                    if warning_text in line:' >> /tmp/check_warnings.py
        echo '                        actual_line_num = block_line + i' >> /tmp/check_warnings.py
        echo '                        # Clean up the line for display (remove extra whitespace, HTML tags)' >> /tmp/check_warnings.py
        echo '                        clean_line = re.sub(r"<[^>]+>", "", line).strip()' >> /tmp/check_warnings.py
        echo '                        if clean_line:  # Only add non-empty lines' >> /tmp/check_warnings.py
        echo '                            matches.append(f"{actual_line_num}:{clean_line}")' >> /tmp/check_warnings.py
        echo '        ' >> /tmp/check_warnings.py
        echo '        # Output results' >> /tmp/check_warnings.py
        echo '        for match in matches:' >> /tmp/check_warnings.py
        echo '            print(match)' >> /tmp/check_warnings.py
        echo '            ' >> /tmp/check_warnings.py
        echo '    except Exception as e:' >> /tmp/check_warnings.py
        echo '        print(f"Error processing file: {e}", file=sys.stderr)' >> /tmp/check_warnings.py
        echo '        sys.exit(1)' >> /tmp/check_warnings.py
        echo '' >> /tmp/check_warnings.py
        echo 'if __name__ == "__main__":' >> /tmp/check_warnings.py
        echo '    file_path = sys.argv[1]' >> /tmp/check_warnings.py
        echo '    warning_text = sys.argv[2]' >> /tmp/check_warnings.py
        echo '    find_warnings_in_cell_outputs(file_path, warning_text)' >> /tmp/check_warnings.py
        
        # Search for warnings in HTML files within cell_output elements
        for file in "${FILES[@]}"; do
          echo "Checking file: $file"
          
          # Skip warning check if no warnings to check for
          if [ ${#WARNING_ARRAY[@]} -eq 0 ]; then
            echo "No warnings to check for in $file (all excluded)"
            continue
          fi
          
          for warning in "${WARNING_ARRAY[@]}"; do
            # Remove leading/trailing whitespace from warning
            warning=$(echo "$warning" | xargs)
            
            # Run the Python script and capture results
            matches=$(python3 /tmp/check_warnings.py "$file" "$warning" 2>/dev/null || true)
            
            if [ -n "$matches" ]; then
              WARNINGS_FOUND="true"
              count=$(echo "$matches" | wc -l)
              TOTAL_WARNINGS=$((TOTAL_WARNINGS + count))
              
              echo "âš ï¸  Found $count instance(s) of '$warning' in $file:"
              echo "$matches"
              
              # Add to basic details
              if [ -n "$WARNING_DETAILS" ]; then
                WARNING_DETAILS="$WARNING_DETAILS\n"
              fi
              WARNING_DETAILS="$WARNING_DETAILS$file: $count instance(s) of '$warning'"
              
              # Add to detailed report
              DETAILED_REPORT="$DETAILED_REPORT## $warning in $file\n\n"
              DETAILED_REPORT="$DETAILED_REPORT**Found $count instance(s):**\n\n"
              DETAILED_REPORT="$DETAILED_REPORT\`\`\`\n"
              DETAILED_REPORT="$DETAILED_REPORT$matches\n"
              DETAILED_REPORT="$DETAILED_REPORT\`\`\`\n\n"
            fi
          done
        done
        
        # Set outputs
        echo "warnings-found=$WARNINGS_FOUND" >> $GITHUB_OUTPUT
        echo "warning-count=$TOTAL_WARNINGS" >> $GITHUB_OUTPUT
        echo "warning-details<<EOF" >> $GITHUB_OUTPUT
        echo -e "$WARNING_DETAILS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        echo "detailed-report<<EOF" >> $GITHUB_OUTPUT
        echo -e "$DETAILED_REPORT" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        # Summary
        if [ "$WARNINGS_FOUND" = "true" ]; then
          echo "âŒ Found $TOTAL_WARNINGS warning(s) in HTML files"
          echo "::error::Found $TOTAL_WARNINGS Python warning(s) in HTML output"
        else
          echo "âœ… No warnings found in HTML files"
        fi

    - name: Post PR comment with warning report
      if: inputs.fail-on-warning == 'true' && steps.check.outputs.warnings-found == 'true' && github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const warningCount = '${{ steps.check.outputs.warning-count }}';
          const detailedReport = ${{ toJSON(steps.check.outputs.detailed-report) }};
          
          const body = [
            '## âš ï¸ Python Warnings Detected',
            '',
            'ðŸš¨ **' + warningCount + ' Python warning(s)** were found in the HTML output during the documentation build.',
            '',
            '**Build Details:**',
            '- **Workflow Run:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})',
            '- **Commit:** ${{ github.sha }}',
            '- **Date:** ' + new Date().toISOString(),
            '',
            '---',
            '',
            detailedReport,
            '',
            '---',
            '',
            '**Next Steps:**',
            '1. Review the warnings listed above',
            '2. Fix the underlying code that\'s generating these warnings',
            '3. Push the changes to update this PR',
            '',
            'ðŸ“ *This comment was automatically generated by the [Check for Python Warnings Action](https://github.com/QuantEcon/meta/.github/actions/check-warnings).*'
          ].join('\n');
          
          try {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });
            console.log('Posted PR comment with warning details');
          } catch (error) {
            console.error('Failed to create PR comment:', error);
            core.setFailed('Failed to create PR comment: ' + error.message);
          }

    - name: Fail workflow on warnings
      if: inputs.fail-on-warning == 'true' && steps.check.outputs.warnings-found == 'true'
      shell: bash
      run: |
        echo "Failing workflow due to warnings found"
        exit 1

    - name: Create artifact with warning report
      id: create-artifact
      if: inputs.create-artifact == 'true' && steps.check.outputs.warnings-found == 'true'
      shell: bash
      run: |
        ARTIFACT_NAME="${{ inputs.artifact-name }}"
        ARTIFACT_FILE="$ARTIFACT_NAME.md"
        CURRENT_DATE=$(date -u '+%Y-%m-%d %H:%M:%S UTC')
        
        # Create the report file
        {
          echo "# Python Warning Report"
          echo ""
          echo "**Date:** $CURRENT_DATE"
          echo "**Repository:** ${{ github.repository }}"
          echo "**Workflow:** ${{ github.workflow }}"
          echo "**Run ID:** ${{ github.run_id }}"
          echo "**Total Warnings Found:** ${{ steps.check.outputs.warning-count }}"
          echo ""
          echo "---"
          echo ""
          echo "${{ steps.check.outputs.detailed-report }}"
          echo ""
          echo "---"
          echo ""
          echo "Generated by [Check for Python Warnings Action](https://github.com/QuantEcon/meta/.github/actions/check-warnings)"
        } > "$ARTIFACT_FILE"
        
        echo "artifact-path=$ARTIFACT_FILE" >> $GITHUB_OUTPUT
        echo "Created warning report artifact: $ARTIFACT_FILE"

    - name: Upload warning report artifact
      if: inputs.create-artifact == 'true' && steps.check.outputs.warnings-found == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.artifact-name }}
        path: ${{ steps.create-artifact.outputs.artifact-path }}
        retention-days: 30

    - name: Create GitHub issue
      id: create-issue
      if: inputs.create-issue == 'true' && steps.check.outputs.warnings-found == 'true'
      uses: actions/github-script@v7
      with:
        script: |
          const warningCount = '${{ steps.check.outputs.warning-count }}';
          const detailedReport = ${{ toJSON(steps.check.outputs.detailed-report) }};
          const title = '${{ inputs.issue-title }}';
          const notify = '${{ inputs.notify }}';
          
          const body = [
            '# Python Warnings Detected',
            '',
            'ðŸš¨ **' + warningCount + ' Python warning(s)** were found in the HTML output during the documentation build.',
            '',
            '**Details:**',
            '- **Repository:** ${{ github.repository }}',
            '- **Workflow:** ${{ github.workflow }}',
            '- **Run ID:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})',
            '- **Commit:** ${{ github.sha }}',
            '- **Branch:** ${{ github.ref_name }}',
            '- **Date:** ' + new Date().toISOString(),
            '',
            '---',
            '',
            detailedReport,
            '',
            '---',
            '',
            '**Next Steps:**',
            '1. Review the warnings listed above',
            '2. Fix the underlying code that\'s generating these warnings',
            '3. Re-run the build to verify the warnings are resolved',
            '',
            '**Note:** This issue was automatically created by the [Check for Python Warnings Action](https://github.com/QuantEcon/meta/.github/actions/check-warnings).',
            '',
            'Please close this issue once all warnings have been addressed.'
          ].join('\n');
          
          try {
            const response = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['bug', 'execution', 'python-warnings']
            });
            
            const issueUrl = response.data.html_url;
            const issueNumber = response.data.number;
            console.log('Created issue: ' + issueUrl);
            core.setOutput('issue-url', issueUrl);
            
            // Assign users to the issue if notify parameter is provided
            if (notify && notify.trim()) {
              try {
                // Parse comma-separated usernames and clean them
                const assignees = notify.split(',')
                  .map(username => username.trim())
                  .filter(username => username.length > 0);
                
                if (assignees.length > 0) {
                  console.log('Assigning issue to users: ' + assignees.join(', '));
                  
                  await github.rest.issues.addAssignees({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    assignees: assignees
                  });
                  
                  console.log('Successfully assigned issue to: ' + assignees.join(', '));
                }
              } catch (assignError) {
                console.error('Failed to assign users to issue:', assignError);
                // Don't fail the entire workflow for assignment errors
                console.log('Issue was created successfully, but assignment failed. Users may need to be assigned manually.');
              }
            }
            
            return issueUrl;
          } catch (error) {
            console.error('Failed to create issue:', error);
            core.setFailed('Failed to create issue: ' + error.message);
          }

    - name: Post simple PR comment linking to issue
      if: inputs.create-issue == 'true' && steps.check.outputs.warnings-found == 'true' && github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const warningDetails = ${{ toJSON(steps.check.outputs.warning-details) }};
          const issueUrl = '${{ steps.create-issue.outputs.issue-url }}';
          
          // Extract file names from warning details
          const files = [];
          const lines = warningDetails.split('\n');
          for (const line of lines) {
            if (line.includes(': ') && line.includes('instance(s) of')) {
              const fileName = line.split(':')[0].trim();
              if (fileName && !files.includes(fileName)) {
                files.push(fileName);
              }
            }
          }
          
          const fileList = files.map(file => `- ${file}`).join('\n');
          
          const body = [
            'There were code execution warnings found in the following files:',
            '',
            fileList,
            '',
            `For further details please check ${issueUrl}`,
            '',
            'Note: This issue was automatically created by the [Check for Python Warnings Action](https://github.com/QuantEcon/meta/.github/actions/check-warnings).'
          ].join('\n');
          
          try {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });
            console.log('Posted simple PR comment linking to issue');
          } catch (error) {
            console.error('Failed to create PR comment:', error);
            core.setFailed('Failed to create PR comment: ' + error.message);
          }

branding:
  icon: 'alert-triangle'
  color: 'orange'