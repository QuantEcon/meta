name: 'Check for Python Warnings'
description: 'Scan HTML files for Python warnings within code cell outputs (avoiding false positives from text content)'
author: 'QuantEcon'

inputs:
  html-path:
    description: 'Path to directory containing HTML files to scan'
    required: false
    default: '.'
  warnings:
    description: 'Comma-separated list of warnings to check for'
    required: false
    default: 'UserWarning,DeprecationWarning,PendingDeprecationWarning,SyntaxWarning,RuntimeWarning,FutureWarning,ImportWarning,UnicodeWarning,BytesWarning,ResourceWarning,EncodingWarning'
  exclude-warning:
    description: 'Comma-separated list of warnings to exclude from checking (can be a single warning or multiple warnings)'
    required: false
    default: ''
  fail-on-warning:
    description: 'Whether to fail the workflow if warnings are found'
    required: false
    default: 'true'
  create-issue:
    description: 'Whether to create a GitHub issue when warnings are found'
    required: false
    default: 'false'
  issue-title:
    description: 'Title for the GitHub issue when warnings are found'
    required: false
    default: 'Python Warnings Found in Documentation Build'
  create-artifact:
    description: 'Whether to create a workflow artifact with the warning report'
    required: false
    default: 'false'
  artifact-name:
    description: 'Name for the workflow artifact containing the warning report'
    required: false
    default: 'warning-report'
  notify:
    description: 'GitHub username(s) to assign to the created issue (comma-separated for multiple users)'
    required: false
    default: ''

outputs:
  warnings-found:
    description: 'Whether warnings were found (true/false)'
    value: ${{ steps.check.outputs.warnings-found }}
  warning-count:
    description: 'Number of warnings found'
    value: ${{ steps.check.outputs.warning-count }}
  warning-details:
    description: 'Details of warnings found'
    value: ${{ steps.check.outputs.warning-details }}
  issue-url:
    description: 'URL of the created GitHub issue (if create-issue is enabled)'
    value: ${{ steps.create-issue.outputs.issue-url }}
  artifact-path:
    description: 'Path to the created artifact file (if create-artifact is enabled)'
    value: ${{ steps.create-artifact.outputs.artifact-path }}

runs:
  using: 'composite'
  steps:
    - name: Check for warnings
      id: check
      shell: bash
      run: |
        # Parse inputs
        HTML_PATH="${{ inputs.html-path }}"
        WARNINGS="${{ inputs.warnings }}"
        EXCLUDE_WARNINGS="${{ inputs.exclude-warning }}"
        FAIL_ON_WARNING="${{ inputs.fail-on-warning }}"
        
        echo "Scanning HTML files in: $HTML_PATH"
        echo "Looking for warnings: $WARNINGS"
        
        # Convert comma-separated warnings to array
        IFS=',' read -ra WARNING_ARRAY <<< "$WARNINGS"
        
        # Handle exclude-warning parameter
        if [ -n "$EXCLUDE_WARNINGS" ]; then
          echo "Excluding warnings: $EXCLUDE_WARNINGS"
          # Convert comma-separated exclude warnings to array
          IFS=',' read -ra EXCLUDE_ARRAY <<< "$EXCLUDE_WARNINGS"
          
          # Create a new array with warnings not in exclude list
          FILTERED_WARNING_ARRAY=()
          for warning in "${WARNING_ARRAY[@]}"; do
            # Remove leading/trailing whitespace from warning
            warning=$(echo "$warning" | xargs)
            exclude_warning=false
            
            # Check if this warning should be excluded
            for exclude in "${EXCLUDE_ARRAY[@]}"; do
              # Remove leading/trailing whitespace from exclude warning
              exclude=$(echo "$exclude" | xargs)
              if [ "$warning" = "$exclude" ]; then
                exclude_warning=true
                break
              fi
            done
            
            # Add to filtered array if not excluded
            if [ "$exclude_warning" = false ]; then
              FILTERED_WARNING_ARRAY+=("$warning")
            fi
          done
          
          # Replace WARNING_ARRAY with filtered array
          WARNING_ARRAY=("${FILTERED_WARNING_ARRAY[@]}")
          
          # Show final warning list
          if [ ${#WARNING_ARRAY[@]} -eq 0 ]; then
            echo "⚠️  All warnings have been excluded. No warnings will be checked."
          else
            echo "Final warning list after exclusions: ${WARNING_ARRAY[*]}"
          fi
        fi
        
        # Initialize counters
        TOTAL_WARNINGS=0
        WARNING_DETAILS=""
        WARNINGS_FOUND="false"
        DETAILED_REPORT=""
        
        # Find all HTML files
        if [ ! -e "$HTML_PATH" ]; then
          echo "Error: HTML path '$HTML_PATH' does not exist"
          exit 1
        fi
        
        # Determine if we're dealing with a file or directory
        if [ -f "$HTML_PATH" ]; then
          # Single file
          if [[ "$HTML_PATH" == *.html ]]; then
            echo "Checking single HTML file: $HTML_PATH"
            FILES=("$HTML_PATH")
          else
            echo "Error: '$HTML_PATH' is not an HTML file"
            exit 1
          fi
        else
          # Directory - find all HTML files
          mapfile -d '' FILES < <(find "$HTML_PATH" -name "*.html" -type f -print0)
        fi
        
        # Create temporary Python script for parsing HTML
        echo 'import re' > /tmp/check_warnings.py
        echo 'import sys' >> /tmp/check_warnings.py
        echo 'import os' >> /tmp/check_warnings.py
        echo '' >> /tmp/check_warnings.py
        echo 'def find_warnings_in_cell_outputs(file_path, warning_text):' >> /tmp/check_warnings.py
        echo '    try:' >> /tmp/check_warnings.py
        echo '        with open(file_path, "r", encoding="utf-8") as f:' >> /tmp/check_warnings.py
        echo '            content = f.read()' >> /tmp/check_warnings.py
        echo '        ' >> /tmp/check_warnings.py
        echo '        # Find all HTML elements with cell_output in the class attribute' >> /tmp/check_warnings.py
        echo '        pattern = r"<([^>]+)\s+class=\"[^\"]*cell_output[^\"]*\"[^>]*>(.*?)</\1>"' >> /tmp/check_warnings.py
        echo '        ' >> /tmp/check_warnings.py
        echo '        matches = []' >> /tmp/check_warnings.py
        echo '        ' >> /tmp/check_warnings.py
        echo '        # Search for cell_output blocks' >> /tmp/check_warnings.py
        echo '        for match in re.finditer(pattern, content, re.DOTALL | re.IGNORECASE):' >> /tmp/check_warnings.py
        echo '            block_content = match.group(2)' >> /tmp/check_warnings.py
        echo '            block_start = match.start()' >> /tmp/check_warnings.py
        echo '            ' >> /tmp/check_warnings.py
        echo '            # Count line number where this block starts' >> /tmp/check_warnings.py
        echo '            block_line = content[:block_start].count("\\n") + 1' >> /tmp/check_warnings.py
        echo '            ' >> /tmp/check_warnings.py
        echo '            # Search for warning within this block' >> /tmp/check_warnings.py
        echo '            if warning_text in block_content:' >> /tmp/check_warnings.py
        echo '                # Find specific lines within the block that contain the warning' >> /tmp/check_warnings.py
        echo '                block_lines = block_content.split("\\n")' >> /tmp/check_warnings.py
        echo '                for i, line in enumerate(block_lines):' >> /tmp/check_warnings.py
        echo '                    if warning_text in line:' >> /tmp/check_warnings.py
        echo '                        actual_line_num = block_line + i' >> /tmp/check_warnings.py
        echo '                        # Clean up the line for display (remove extra whitespace, HTML tags)' >> /tmp/check_warnings.py
        echo '                        clean_line = re.sub(r"<[^>]+>", "", line).strip()' >> /tmp/check_warnings.py
        echo '                        if clean_line:  # Only add non-empty lines' >> /tmp/check_warnings.py
        echo '                            matches.append(f"{actual_line_num}:{clean_line}")' >> /tmp/check_warnings.py
        echo '        ' >> /tmp/check_warnings.py
        echo '        # Output results' >> /tmp/check_warnings.py
        echo '        for match in matches:' >> /tmp/check_warnings.py
        echo '            print(match)' >> /tmp/check_warnings.py
        echo '            ' >> /tmp/check_warnings.py
        echo '    except Exception as e:' >> /tmp/check_warnings.py
        echo '        print(f"Error processing file: {e}", file=sys.stderr)' >> /tmp/check_warnings.py
        echo '        sys.exit(1)' >> /tmp/check_warnings.py
        echo '' >> /tmp/check_warnings.py
        echo 'if __name__ == "__main__":' >> /tmp/check_warnings.py
        echo '    file_path = sys.argv[1]' >> /tmp/check_warnings.py
        echo '    warning_text = sys.argv[2]' >> /tmp/check_warnings.py
        echo '    find_warnings_in_cell_outputs(file_path, warning_text)' >> /tmp/check_warnings.py
        
        # Search for warnings in HTML files within cell_output elements
        for file in "${FILES[@]}"; do
          echo "Checking file: $file"
          
          # Skip warning check if no warnings to check for
          if [ ${#WARNING_ARRAY[@]} -eq 0 ]; then
            echo "No warnings to check for in $file (all excluded)"
            continue
          fi
          
          for warning in "${WARNING_ARRAY[@]}"; do
            # Remove leading/trailing whitespace from warning
            warning=$(echo "$warning" | xargs)
            
            # Run the Python script and capture results
            matches=$(python3 /tmp/check_warnings.py "$file" "$warning" 2>/dev/null || true)
            
            if [ -n "$matches" ]; then
              WARNINGS_FOUND="true"
              count=$(echo "$matches" | wc -l)
              TOTAL_WARNINGS=$((TOTAL_WARNINGS + count))
              
              echo "⚠️  Found $count instance(s) of '$warning' in $file:"
              echo "$matches"
              
              # Add to basic details
              if [ -n "$WARNING_DETAILS" ]; then
                WARNING_DETAILS="$WARNING_DETAILS\n"
              fi
              WARNING_DETAILS="$WARNING_DETAILS$file: $count instance(s) of '$warning'"
              
              # Add to detailed report
              DETAILED_REPORT="$DETAILED_REPORT## $warning in $file\n\n"
              DETAILED_REPORT="$DETAILED_REPORT**Found $count instance(s):**\n\n"
              DETAILED_REPORT="$DETAILED_REPORT\`\`\`\n"
              DETAILED_REPORT="$DETAILED_REPORT$matches\n"
              DETAILED_REPORT="$DETAILED_REPORT\`\`\`\n\n"
            fi
          done
        done
        
        # Set outputs
        echo "warnings-found=$WARNINGS_FOUND" >> $GITHUB_OUTPUT
        echo "warning-count=$TOTAL_WARNINGS" >> $GITHUB_OUTPUT
        echo "warning-details<<EOF" >> $GITHUB_OUTPUT
        echo -e "$WARNING_DETAILS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        echo "detailed-report<<EOF" >> $GITHUB_OUTPUT
        echo -e "$DETAILED_REPORT" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        # Summary
        if [ "$WARNINGS_FOUND" = "true" ]; then
          echo "❌ Found $TOTAL_WARNINGS warning(s) in HTML files"
          echo "::error::Found $TOTAL_WARNINGS Python warning(s) in HTML output"
        else
          echo "✅ No warnings found in HTML files"
        fi

    - name: Post PR comment with warning report
      if: inputs.fail-on-warning == 'true' && steps.check.outputs.warnings-found == 'true' && github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const warningCount = '${{ steps.check.outputs.warning-count }}';
          const detailedReport = ${{ toJSON(steps.check.outputs.detailed-report) }};
          
          const body = [
            '## ⚠️ Python Warnings Detected',
            '',
            '🚨 **' + warningCount + ' Python warning(s)** were found in the HTML output during the documentation build.',
            '',
            '**Build Details:**',
            '- **Workflow Run:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})',
            '- **Commit:** ${{ github.sha }}',
            '- **Date:** ' + new Date().toISOString(),
            '',
            '---',
            '',
            detailedReport,
            '',
            '---',
            '',
            '**Next Steps:**',
            '1. Review the warnings listed above',
            '2. Fix the underlying code that\'s generating these warnings',
            '3. Push the changes to update this PR',
            '',
            '📝 *This comment was automatically generated by the [Check for Python Warnings Action](https://github.com/QuantEcon/meta/.github/actions/check-warnings).*'
          ].join('\n');
          
          try {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });
            console.log('Posted PR comment with warning details');
          } catch (error) {
            console.error('Failed to create PR comment:', error);
            core.setFailed('Failed to create PR comment: ' + error.message);
          }

    - name: Fail workflow on warnings
      if: inputs.fail-on-warning == 'true' && steps.check.outputs.warnings-found == 'true'
      shell: bash
      run: |
        echo "Failing workflow due to warnings found"
        exit 1

    - name: Create artifact with warning report
      id: create-artifact
      if: inputs.create-artifact == 'true' && steps.check.outputs.warnings-found == 'true'
      shell: bash
      run: |
        ARTIFACT_NAME="${{ inputs.artifact-name }}"
        ARTIFACT_FILE="$ARTIFACT_NAME.md"
        CURRENT_DATE=$(date -u '+%Y-%m-%d %H:%M:%S UTC')
        
        # Create the report file
        {
          echo "# Python Warning Report"
          echo ""
          echo "**Date:** $CURRENT_DATE"
          echo "**Repository:** ${{ github.repository }}"
          echo "**Workflow:** ${{ github.workflow }}"
          echo "**Run ID:** ${{ github.run_id }}"
          echo "**Total Warnings Found:** ${{ steps.check.outputs.warning-count }}"
          echo ""
          echo "---"
          echo ""
          echo "${{ steps.check.outputs.detailed-report }}"
          echo ""
          echo "---"
          echo ""
          echo "Generated by [Check for Python Warnings Action](https://github.com/QuantEcon/meta/.github/actions/check-warnings)"
        } > "$ARTIFACT_FILE"
        
        echo "artifact-path=$ARTIFACT_FILE" >> $GITHUB_OUTPUT
        echo "Created warning report artifact: $ARTIFACT_FILE"

    - name: Upload warning report artifact
      if: inputs.create-artifact == 'true' && steps.check.outputs.warnings-found == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.artifact-name }}
        path: ${{ steps.create-artifact.outputs.artifact-path }}
        retention-days: 30

    - name: Create GitHub issue
      id: create-issue
      if: inputs.create-issue == 'true' && steps.check.outputs.warnings-found == 'true'
      uses: actions/github-script@v7
      with:
        script: |
          const warningCount = '${{ steps.check.outputs.warning-count }}';
          const detailedReport = ${{ toJSON(steps.check.outputs.detailed-report) }};
          const title = '${{ inputs.issue-title }}';
          const notify = '${{ inputs.notify }}';
          
          const body = [
            '# Python Warnings Detected',
            '',
            '🚨 **' + warningCount + ' Python warning(s)** were found in the HTML output during the documentation build.',
            '',
            '**Details:**',
            '- **Repository:** ${{ github.repository }}',
            '- **Workflow:** ${{ github.workflow }}',
            '- **Run ID:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})',
            '- **Commit:** ${{ github.sha }}',
            '- **Branch:** ${{ github.ref_name }}',
            '- **Date:** ' + new Date().toISOString(),
            '',
            '---',
            '',
            detailedReport,
            '',
            '---',
            '',
            '**Next Steps:**',
            '1. Review the warnings listed above',
            '2. Fix the underlying code that\'s generating these warnings',
            '3. Re-run the build to verify the warnings are resolved',
            '',
            '**Note:** This issue was automatically created by the [Check for Python Warnings Action](https://github.com/QuantEcon/meta/.github/actions/check-warnings).',
            '',
            'Please close this issue once all warnings have been addressed.'
          ].join('\n');
          
          try {
            const response = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['bug', 'execution', 'python-warnings']
            });
            
            const issueUrl = response.data.html_url;
            const issueNumber = response.data.number;
            console.log('Created issue: ' + issueUrl);
            core.setOutput('issue-url', issueUrl);
            
            // Assign users to the issue if notify parameter is provided
            if (notify && notify.trim()) {
              try {
                // Parse comma-separated usernames and clean them
                const assignees = notify.split(',')
                  .map(username => username.trim())
                  .filter(username => username.length > 0);
                
                if (assignees.length > 0) {
                  console.log('Assigning issue to users: ' + assignees.join(', '));
                  
                  await github.rest.issues.addAssignees({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    assignees: assignees
                  });
                  
                  console.log('Successfully assigned issue to: ' + assignees.join(', '));
                }
              } catch (assignError) {
                console.error('Failed to assign users to issue:', assignError);
                // Don't fail the entire workflow for assignment errors
                console.log('Issue was created successfully, but assignment failed. Users may need to be assigned manually.');
              }
            }
            
            return issueUrl;
          } catch (error) {
            console.error('Failed to create issue:', error);
            core.setFailed('Failed to create issue: ' + error.message);
          }

    - name: Post simple PR comment linking to issue
      if: inputs.create-issue == 'true' && steps.check.outputs.warnings-found == 'true' && github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const warningDetails = ${{ toJSON(steps.check.outputs.warning-details) }};
          const issueUrl = '${{ steps.create-issue.outputs.issue-url }}';
          
          // Extract file names from warning details
          const files = [];
          const lines = warningDetails.split('\n');
          for (const line of lines) {
            if (line.includes(': ') && line.includes('instance(s) of')) {
              const fileName = line.split(':')[0].trim();
              if (fileName && !files.includes(fileName)) {
                files.push(fileName);
              }
            }
          }
          
          const fileList = files.map(file => `- ${file}`).join('\n');
          
          const body = [
            'There were code execution warnings found in the following files:',
            '',
            fileList,
            '',
            `For further details please check ${issueUrl}`,
            '',
            'Note: This issue was automatically created by the [Check for Python Warnings Action](https://github.com/QuantEcon/meta/.github/actions/check-warnings).'
          ].join('\n');
          
          try {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });
            console.log('Posted simple PR comment linking to issue');
          } catch (error) {
            console.error('Failed to create PR comment:', error);
            core.setFailed('Failed to create PR comment: ' + error.message);
          }

branding:
  icon: 'alert-triangle'
  color: 'orange'