name: 'Check for Python Warnings'
description: 'Scan HTML files for Python warnings within code cell outputs (avoiding false positives from text content)'
author: 'QuantEcon'

inputs:
  html-path:
    description: 'Path to directory containing HTML files to scan'
    required: false
    default: '.'
  warnings:
    description: 'Comma-separated list of warnings to check for'
    required: false
    default: 'SyntaxWarning,DeprecationWarning,FutureWarning'
  fail-on-warning:
    description: 'Whether to fail the workflow if warnings are found'
    required: false
    default: 'true'
  create-issue:
    description: 'Whether to create a GitHub issue when warnings are found'
    required: false
    default: 'false'
  issue-title:
    description: 'Title for the GitHub issue when warnings are found'
    required: false
    default: 'Python Warnings Found in Documentation Build'
  create-artifact:
    description: 'Whether to create a workflow artifact with the warning report'
    required: false
    default: 'false'
  artifact-name:
    description: 'Name for the workflow artifact containing the warning report'
    required: false
    default: 'warning-report'

outputs:
  warnings-found:
    description: 'Whether warnings were found (true/false)'
    value: ${{ steps.check.outputs.warnings-found }}
  warning-count:
    description: 'Number of warnings found'
    value: ${{ steps.check.outputs.warning-count }}
  warning-details:
    description: 'Details of warnings found'
    value: ${{ steps.check.outputs.warning-details }}
  issue-url:
    description: 'URL of the created GitHub issue (if create-issue is enabled)'
    value: ${{ steps.create-issue.outputs.issue-url }}
  artifact-path:
    description: 'Path to the created artifact file (if create-artifact is enabled)'
    value: ${{ steps.create-artifact.outputs.artifact-path }}

runs:
  using: 'composite'
  steps:
    - name: Check for warnings
      id: check
      shell: bash
      run: |
        # Parse inputs
        HTML_PATH="${{ inputs.html-path }}"
        WARNINGS="${{ inputs.warnings }}"
        FAIL_ON_WARNING="${{ inputs.fail-on-warning }}"
        
        echo "Scanning HTML files in: $HTML_PATH"
        echo "Looking for warnings: $WARNINGS"
        
        # Convert comma-separated warnings to array
        IFS=',' read -ra WARNING_ARRAY <<< "$WARNINGS"
        
        # Initialize counters
        TOTAL_WARNINGS=0
        WARNING_DETAILS=""
        WARNINGS_FOUND="false"
        DETAILED_REPORT=""
        
        # Find all HTML files
        if [ ! -e "$HTML_PATH" ]; then
          echo "Error: HTML path '$HTML_PATH' does not exist"
          exit 1
        fi
        
        # Determine if we're dealing with a file or directory
        if [ -f "$HTML_PATH" ]; then
          # Single file
          if [[ "$HTML_PATH" == *.html ]]; then
            echo "Checking single HTML file: $HTML_PATH"
            FILES=("$HTML_PATH")
          else
            echo "Error: '$HTML_PATH' is not an HTML file"
            exit 1
          fi
        else
          # Directory - find all HTML files
          mapfile -d '' FILES < <(find "$HTML_PATH" -name "*.html" -type f -print0)
        fi
        
        # Search for warnings in HTML files within cell_output elements
        for file in "${FILES[@]}"; do
          echo "Checking file: $file"
          
          for warning in "${WARNING_ARRAY[@]}"; do
            # Remove leading/trailing whitespace from warning
            warning=$(echo "$warning" | xargs)
            
            # Create temporary Python script for parsing HTML
            cat > /tmp/check_warnings.py << 'EOF'
            import re
            import sys
            import os
            
            def find_warnings_in_cell_outputs(file_path, warning_text):
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    # Find all HTML elements with cell_output in the class attribute
                    pattern = r'<([^>]+)\s+class="[^"]*cell_output[^"]*"[^>]*>(.*?)</\1>'
                    
                    matches = []
                    
                    # Search for cell_output blocks
                    for match in re.finditer(pattern, content, re.DOTALL | re.IGNORECASE):
                        block_content = match.group(2)
                        block_start = match.start()
                        
                        # Count line number where this block starts
                        block_line = content[:block_start].count('\n') + 1
                        
                        # Search for warning within this block
                        if warning_text in block_content:
                            # Find specific lines within the block that contain the warning
                            block_lines = block_content.split('\n')
                            for i, line in enumerate(block_lines):
                                if warning_text in line:
                                    actual_line_num = block_line + i
                                    # Clean up the line for display (remove extra whitespace, HTML tags)
                                    clean_line = re.sub(r'<[^>]+>', '', line).strip()
                                    if clean_line:  # Only add non-empty lines
                                        matches.append(f'{actual_line_num}:{clean_line}')
                    
                    # Output results
                    for match in matches:
                        print(match)
                        
                except Exception as e:
                    print(f'Error processing file: {e}', file=sys.stderr)
                    sys.exit(1)
            
            if __name__ == "__main__":
                file_path = sys.argv[1]
                warning_text = sys.argv[2]
                find_warnings_in_cell_outputs(file_path, warning_text)
            EOF
            
            # Run the Python script and capture results
            matches=$(python3 /tmp/check_warnings.py "$file" "$warning" 2>/dev/null || true)
            
            if [ -n "$matches" ]; then
              WARNINGS_FOUND="true"
              count=$(echo "$matches" | wc -l)
              TOTAL_WARNINGS=$((TOTAL_WARNINGS + count))
              
              echo "⚠️  Found $count instance(s) of '$warning' in $file:"
              echo "$matches"
              
              # Add to basic details
              if [ -n "$WARNING_DETAILS" ]; then
                WARNING_DETAILS="$WARNING_DETAILS\n"
              fi
              WARNING_DETAILS="$WARNING_DETAILS$file: $count instance(s) of '$warning'"
              
              # Add to detailed report
              DETAILED_REPORT="$DETAILED_REPORT## $warning in $file\n\n"
              DETAILED_REPORT="$DETAILED_REPORT**Found $count instance(s):**\n\n"
              DETAILED_REPORT="$DETAILED_REPORT\`\`\`\n"
              DETAILED_REPORT="$DETAILED_REPORT$matches\n"
              DETAILED_REPORT="$DETAILED_REPORT\`\`\`\n\n"
            fi
          done
        done
        
        # Set outputs
        echo "warnings-found=$WARNINGS_FOUND" >> $GITHUB_OUTPUT
        echo "warning-count=$TOTAL_WARNINGS" >> $GITHUB_OUTPUT
        echo "warning-details<<EOF" >> $GITHUB_OUTPUT
        echo -e "$WARNING_DETAILS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        echo "detailed-report<<EOF" >> $GITHUB_OUTPUT
        echo -e "$DETAILED_REPORT" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        # Summary
        if [ "$WARNINGS_FOUND" = "true" ]; then
          echo "❌ Found $TOTAL_WARNINGS warning(s) in HTML files"
          echo "::error::Found $TOTAL_WARNINGS Python warning(s) in HTML output"
          
          if [ "$FAIL_ON_WARNING" = "true" ]; then
            echo "Failing workflow due to warnings found"
            exit 1
          fi
        else
          echo "✅ No warnings found in HTML files"
        fi

    - name: Create artifact with warning report
      id: create-artifact
      if: inputs.create-artifact == 'true' && steps.check.outputs.warnings-found == 'true'
      shell: bash
      run: |
        ARTIFACT_NAME="${{ inputs.artifact-name }}"
        ARTIFACT_FILE="$ARTIFACT_NAME.md"
        CURRENT_DATE=$(date -u '+%Y-%m-%d %H:%M:%S UTC')
        
        # Create the report file
        cat > "$ARTIFACT_FILE" << EOF
        # Python Warning Report
        
        **Date:** $CURRENT_DATE
        **Repository:** ${{ github.repository }}
        **Workflow:** ${{ github.workflow }}
        **Run ID:** ${{ github.run_id }}
        **Total Warnings Found:** ${{ steps.check.outputs.warning-count }}
        
        ---
        
        ${{ steps.check.outputs.detailed-report }}
        
        ---
        
        Generated by [Check for Python Warnings Action](https://github.com/QuantEcon/meta/.github/actions/check-warnings)
        EOF
        
        echo "artifact-path=$ARTIFACT_FILE" >> $GITHUB_OUTPUT
        echo "Created warning report artifact: $ARTIFACT_FILE"

    - name: Upload warning report artifact
      if: inputs.create-artifact == 'true' && steps.check.outputs.warnings-found == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.artifact-name }}
        path: ${{ steps.create-artifact.outputs.artifact-path }}
        retention-days: 30

    - name: Create GitHub issue
      id: create-issue
      if: inputs.create-issue == 'true' && steps.check.outputs.warnings-found == 'true'
      uses: actions/github-script@v7
      with:
        script: |
          const warningCount = '${{ steps.check.outputs.warning-count }}';
          const detailedReport = `${{ steps.check.outputs.detailed-report }}`;
          const title = '${{ inputs.issue-title }}';
          
          const body = `# Python Warnings Detected
          
          🚨 **${{ steps.check.outputs.warning-count }} Python warning(s)** were found in the HTML output during the documentation build.
          
          **Details:**
          - **Repository:** ${{ github.repository }}
          - **Workflow:** ${{ github.workflow }}
          - **Run ID:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - **Commit:** ${{ github.sha }}
          - **Branch:** ${{ github.ref_name }}
          - **Date:** ${new Date().toISOString()}
          
          ---
          
          ${detailedReport}
          
          ---
          
          **Next Steps:**
          1. Review the warnings listed above
          2. Fix the underlying code that's generating these warnings
          3. Re-run the build to verify the warnings are resolved
          
          **Note:** This issue was automatically created by the [Check for Python Warnings Action](https://github.com/QuantEcon/meta/.github/actions/check-warnings).
          
          Please close this issue once all warnings have been addressed.`;
          
          try {
            const response = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['bug', 'documentation', 'python-warnings']
            });
            
            const issueUrl = response.data.html_url;
            console.log(`Created issue: ${issueUrl}`);
            core.setOutput('issue-url', issueUrl);
            
            return issueUrl;
          } catch (error) {
            console.error('Failed to create issue:', error);
            core.setFailed(`Failed to create issue: ${error.message}`);
          }

branding:
  icon: 'alert-triangle'
  color: 'orange'